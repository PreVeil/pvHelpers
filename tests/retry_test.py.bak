import unittest
import time, requests, sqlalchemy
import pvHelpers as H

class DummyCount:
    def __init__(self):
        self.call_count = 0

class DummyException(Exception):
    def __init__(self, message):
        super(DummyException, self).__init__(message)

# Makes functions that raise the exceptions in the provided order.
# returns successfully on call number: ${len(raises)}
# This is just to emulate possible occurence of exceptions in the wrapped functions
def function_maker(raises=[]):
    c = DummyCount()

    def dummy_func(*args, **kwargs):
        if c.call_count >= len(raises):
            return u"success, positional args: {}, named args: {}".format(list(args), kwargs)

        c.call_count += 1
        raise raises[c.call_count-1]("raising on dummy call {}".format(c.call_count-1))

    return dummy_func

class RetryTests(unittest.TestCase):
    def testFailingRetry(self):
        raising_exceptions = [Exception, requests.exceptions.RequestException]
        try_count = 2
        func = function_maker(raises=raising_exceptions)
        failed = False
        try:
            ret_value = H.retry(func, count=try_count)
        except Exception as e:
            failed = True

        self.assertTrue(failed)
        self.assertTrue(isinstance(e, H.RetryError))
        # messages are important, so not to loose trace of what has happened internal to the retry wrapper
        self.assertEqual(e.message, \
            u"Function failed {} times throwing {}".format(try_count, \
            [(e, "raising on dummy call {}".format(i)) for i, e in enumerate(raising_exceptions[:try_count])]))

    def testRetryWithUnexpectedException(self):
        raising_exceptions = [requests.exceptions.RequestException, sqlalchemy.exc.SQLAlchemyError]
        func = function_maker(raises=raising_exceptions)
        try_count = 3
        failed = False
        try:
            ret_value = H.retry(func, exceptions=raising_exceptions[:1], count=try_count)
        except Exception as e:
            failed = True

        self.assertTrue(failed)
        self.assertTrue(isinstance(e, sqlalchemy.exc.SQLAlchemyError))
        self.assertEqual(e.message, "raising on dummy call {}".format(1))

    def testRetryWithExceptionWrapping(self):
        # wrapping unexpected exception
        raising_exceptions = [IndexError, IndexError, ValueError]
        func = function_maker(raises=raising_exceptions)
        try_count = 6
        failed = False
        try:
            # not including last exception type so it dummmy function throws in the third call.
            ret_value = H.retry(func, exceptions=raising_exceptions[:2], wrapping_exception=DummyException, count=try_count)
        except Exception as e:
            failed = True

        self.assertTrue(failed)
        self.assertTrue(isinstance(e, DummyException))

        # wrapping failure with DummyException, instead of RetryError
        func = function_maker(raises=raising_exceptions)
        try_count = 2
        failed = False
        try:
            ret_value = H.retry(func, exceptions=raising_exceptions, wrapping_exception=DummyException, count=try_count)
        except Exception as e:
            failed = True

        self.assertTrue(failed)
        self.assertTrue(isinstance(e, DummyException))
        self.assertEqual(e.message, \
            u"Function failed {} times throwing {}".format(try_count, \
            [(e, "raising on dummy call {}".format(i)) for i, e in enumerate(raising_exceptions[:try_count])]))

    def testPassingRetry(self):
        raising_exceptions = [Exception, requests.exceptions.RequestException]
        func = function_maker(raises=raising_exceptions)
        try_count = 3
        failed = False
        try:
            ret_value = H.retry(func, exceptions=raising_exceptions, count=try_count)
        except Exception as e:
            failed = True

        self.assertFalse(failed)
        self.assertEqual(ret_value, u"success, positional args: {}, named args: {}".format([], {}))

    def testRetryWithArguments(self):
        raising_exceptions = [requests.exceptions.RequestException]
        func = function_maker(raises=raising_exceptions)
        try_count = 3
        _args = ["arg 1", 2]
        _kwargs = {"hi": "bye"}
        failed = False
        try:
            ret_value = H.retry(func, _args, _kwargs, exceptions=raising_exceptions, count=try_count)
        except Exception as e:
            failed = True

        self.assertFalse(failed)
        self.assertEqual(ret_value, u"success, positional args: {}, named args: {}".format(_args, _kwargs))

    def testRetryWithWait(self):
        raising_exceptions = [requests.exceptions.RequestException for _ in xrange(5)]
        func = function_maker(raises=raising_exceptions)
        try_count = 6
        _wait = 0.5
        failed = False
        start = time.time()
        try:
            ret_value = H.retry(func, wait=_wait, exceptions=raising_exceptions, count=try_count)
        except Exception as e:
            failed = True

        self.assertTrue((time.time() - start) >= (try_count-1)*_wait)
        self.assertFalse(failed)
        self.assertEqual(ret_value, u"success, positional args: {}, named args: {}".format([], {}))
